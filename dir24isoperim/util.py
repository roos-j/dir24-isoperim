# (c) 2024 Joris Roos <jroos.math@gmail.com>

''' Utility functions '''

import re

# Logging

class Log: # pylint: disable=too-few-public-methods
    '''Container for log level'''
    lvl = 0

def log(msg, indent=-1, end="\n"):
    '''Log message'''
    if indent < 0:
        indent = Log.lvl
    print(indent*3*" " + msg, end=end)

def err(msg):
    '''Log an error'''
    log(FMT_FAIL%"Error: " + msg)

def warn(msg):
    '''Log a warning'''
    log(FMT_WARN%"Warning: " + msg)

FMT_PASS = "\033[1;92m%s\033[0m"
FMT_FAIL = "\033[1;91m%s\033[0m"
FMT_WARN = "\033[1;93m%s\033[0m"


# Partition data output

_PREAMBLE = \
"""''' This file is automatically generated
Any changes may be overwritten'''

"""

_PREAMBLE_FMT = \
'''# Format: partition into intervals = [ x1, x2, x3, ... ]
# partition into rectangles = [ ((xmin, xmax), (ymin, ymax)), ... ]

'''

_MAX_LINE_LEN = 80

class Output:
    '''Manage output of partition data to file.'''
    _inst = None

    def get_instance(): # pylint: disable=no-method-argument
        '''Get singleton instance.'''
        if Output._inst is None:
            Output._inst = Output()
        return Output._inst

    def __init__(self):
        '''Initialize file handle and singleton.'''
        self._fh = None
        Output._inst = self

    def open(self, filename):
        '''Open specified file.'''
        # pylint: disable=consider-using-with
        try:
            self._fh = open(filename, "w", encoding="utf-8")
            self._fh.write(_PREAMBLE)
            self._fh.write(_PREAMBLE_FMT)
            return True
        except IOError:
            err(f"Couldn't write to file '{filename}'")
            self._fh = None
            return False

    def write(self, data):
        '''Write data to file.'''
        if self._fh is None:
            return
        try:
            self._fh.write(data)
        except IOError:
            err("Error while writing to file.")
            self._fh = None

    def write_comment(self, comment):
        '''Write a comment.'''
        self.write(f"# {comment}\n")

    def write_part(self, lbl, part, comment):
        '''Write partition data.'''
        self.write_comment(comment)
        part_repr = "["
        first = True
        line_len = 1
        for rect in part:
            if not first:
                if line_len > _MAX_LINE_LEN:
                    part_repr += ",\n"+" "*4
                    line_len = 0
                else:
                    part_repr += ", "
            first = False
            if isinstance(rect, tuple):
                rect_repr = f"(({exact_to_str(rect[0][0])}, {exact_to_str(rect[0][1])}), " + \
                        f"({exact_to_str(rect[1][0])}, {exact_to_str(rect[1][1])}))"
            else:
                rect_repr = exact_to_str(rect)
            line_len += len(rect_repr)
            part_repr += rect_repr
        part_repr += "]"
        self.write(f"{lbl} = {part_repr}\n\n")

    def close(self):
        '''Close file.'''
        if not self._fh is None:
            self._fh.close()
            self._fh = None

def exact_to_str(x):
    '''Convert exact arb to string.'''
    assert(x.is_exact())
    num, denom = x.man_exp()
    denom = 2**-denom
    if num == 0: 
        return "\"0\""
    if denom == 1:
        return f"\"{num}\""
    return f"\"{num}/{denom}\""

# Label file generation

RE_AUTO_LABEL = r"\\newlabel\{eqn:(.*)_auto\}.*([0-9]+\.[0-9]+)"

def parse_aux(file = "main.aux"):
    '''Parse auxiliary file as created by LaTeX.'''
    auto_labels = {}
    try:
        with open(file, "r", encoding="utf-8") as f:
            ln = f.readline()
            while ln:
                match = re.search(RE_AUTO_LABEL, ln)
                if match:
                    auto_labels[match.group(1)] = match.group(2)
                ln = f.readline()
    except IOError:
        err(f"Could not read from file '{file}'")
    return auto_labels

def write_labels(labels, file = "dir24isoperim/labels.py"):
    '''Write labels as parsed from .aux file.'''
    try:
        with open(file, "w", encoding="utf-8") as f:
            f.write(_PREAMBLE)
            f.write("lbl_dict = {%s}\n"%",\n    "
                    .join([f"'{k}':'{v}'" for k, v in labels.items()]))
    except IOError:
        err(f"Could not write to file '{file}'")
