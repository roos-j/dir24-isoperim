''' Utility functions '''

import re

# Logging

class Log: # pylint: disable=too-few-public-methods
    '''Container for log level'''
    lvl = 0

def log(msg, indent=-1, end="\n"):
    '''Log message'''
    if indent < 0:
        indent = Log.lvl
    print(indent*3*" " + msg, end=end)

def err(msg):
    '''Log an error'''
    log(FMT_FAIL%"Error: " + msg)

def warn(msg):
    '''Log a warning'''
    log(FMT_WARN%"Warning: " + msg)

FMT_PASS = "\033[1;92m%s\033[0m"
FMT_FAIL = "\033[1;91m%s\033[0m"
FMT_WARN = "\033[1;93m%s\033[0m"


# Partition data output

_PREAMBLE = \
"""''' This file is automatically generated
Any changes may be overwritten'''

"""

_PREAMBLE_FMT = \
'''# Format: partition into intervals = [ x1, x2, x3, ... ]
# partition into rectangles = [ ((xmin, xmax), (ymin, ymax)), ... ]

'''

class Output:
    '''Manage output of partition data to file.'''
    _inst = None

    def get_instance(): # pylint: disable=no-method-argument
        '''Get singleton instance.'''
        if Output._inst is None:
            Output._inst = Output()
        return Output._inst

    def __init__(self):
        '''Initialize file handle and singleton.'''
        self._fh = None
        Output._inst = self

    def open(self, filename):
        '''Open specified file.'''
        # pylint: disable=consider-using-with
        try:
            self._fh = open(filename, "w", encoding="utf-8")
            self._fh.write(_PREAMBLE)
            self._fh.write(_PREAMBLE_FMT)
            return True
        except IOError:
            err(f"Couldn't write to file '{filename}'")
            self._fh = None
            return False

    def write(self, data):
        '''Write data to file.'''
        if self._fh is None:
            return
        try:
            self._fh.write(data)
        except IOError:
            err("Error while writing to file.")
            self._fh = None

    def write_comment(self, comment):
        '''Write a comment.'''
        self.write(f"# {comment}\n")

    def write_part(self, lbl, part, comment):
        '''Write partition data.'''
        self.write_comment(comment)
        self.write(f"{lbl} = {repr(part)}\n\n")

    def close(self):
        '''Close file.'''
        if not self._fh is None:
            self._fh.close()
            self._fh = None

# Label file generation

RE_AUTO_LABEL = r"\\newlabel\{eqn:(.*)_auto\}.*([0-9]+\.[0-9]+)"

def parse_aux(file = "main.aux"):
    '''Parse auxiliary file as created by LaTeX.'''
    auto_labels = {}
    try:
        with open(file, "r", encoding="utf-8") as f:
            ln = f.readline()
            while ln:
                match = re.search(RE_AUTO_LABEL, ln)
                if match:
                    auto_labels[match.group(1)] = match.group(2)
                ln = f.readline()
    except IOError:
        err(f"Could not read from file '{file}'")
    return auto_labels

def write_labels(labels, file = "dir24isoperim/labels.py"):
    '''Write labels as parsed from .aux file.'''
    try:
        with open(file, "w", encoding="utf-8") as f:
            f.write(_PREAMBLE)
            f.write("lbl_dict = {%s}\n"%",\n    "
                    .join([f"'{k}':'{v}'" for k, v in labels.items()]))
    except IOError:
        err(f"Could not write to file '{file}'")
